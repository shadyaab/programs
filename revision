Encapsulation
  - Wrapping of the data(field) and behaviour(method) into a single unit is called encapsulation
  - In encapsulation, the variables of a class will be hidden from other classes, 
      and can be accessed only through the methods of their current class
  - It is also called data hinding
  - It is a protective shield that prevents the data from being accessed by the code outside this shield.
  - Benefits
      - The fields of a class can be made read-only or write-only.
      - A class can have total control over what is stored in its fields

Polymorphism
  - Polymorphism is the ability of an object to take on many forms
  - Poly mean many and morphs mean form -> polymorphism mean many form

Abstraction
  - 

Access Specifier
  private  - same class
  protected - derived class/within same package
  default - derived class/ any package
  public - access anywhere.
  
Composition 
  - has a relationship
  - Creating object in another class.
  - It is used when you want to access feature of an existing class.
  - Ex. :  Car has a Engine
  
Aggregation 
  - dynamic composition
  
Association
  - 

Inheritance
  - IS a relationship
  - It like verionsing the feature of an existing class.
  
Note: 
  - islike-a-relationship: If class is derived as well as inherited.
  - Ex. :  B extends A implement I


JavaDocs 
  - Embed HtMl
  - doc Tags
  
============================================================================================
Operators 
===========================================================================================
# Argument(Non-primitive) in method call is "Pass by Reference".
# Follows BODMAS rule

long a = 23;     //Valid
long a = 23l;    //Valid
long a = 23L;    //Valid

Long a = 23;     //Not Valid
Long a = 23l;    //Valid
Long a = 23L;    //Valid

* Same for all others like Double, float...

float f = 1.39 e-43f
  - It means 1.39 X (10 to the power -43)
  - Compiler normally takes exponential as Double, so trailing f is required.
  - In maths it means (1.39 X (e to power -43)). e refer to 2.718
  - double f1 = 2e2    // 200
  
float f1 = 3.2;  // Invalid since 3.2 is double  

if(i1 = i2)     // Invalid  (i1, i2 is int)
if(b1 = b2)     // Valid    (b1, b2 is boolean)

sizeOf()        //Its not in java since all the data types are same on different machine 


============================================================================================
Controlling Execution
============================================================================================

for(int i = 1, j = i + 10; i < 5; i++, j = i * 2) {
      System.out.println("i = " + i + " j = " + j);
}

  - Can define multiple variables
  - It should be of same type
  - pre increment or post increment doesn't impact
  
for(int i : range(10)){
  System.out.println("i = " + i);
}
  - forEach 
  - Range Automatically generate appropiate array
  
============================================================================================
Keywords
============================================================================================
final 
  - Value cannot be changes once assigned.
  - if we make reference as final, we cannnot change the reference and point to other object but the values of the Object can be 
    modified.
  - Value can be assing in final varible in two places
      1. When is declared.
      2. In constructor
  - We can declare final in the method argument
  - Any private member is implicitly final.
  - If used with class  -> Class cannot be extended.
  - If used with metohd -> Method cannot be overriden
  - If used with variable -> Value/Reference cannnot be changed.
  
abstract
  - 




============================================================================================
Inheritance 
============================================================================================

* In inheritance, subObject of base class is placed inside the derived class.
* Overloading works accross scopes
	i.e. Method in derived class and method is base class with same name can be considered as overloading

Overriding 
  - Same Signature
  - Covarient return type (Is-a-relationship)
  - Cannot reduce visibility
  - Exception 
      - If super class doesn't declare exception 
            -> Can't declare any checked exception
            -> It can declare checked exception.
      - If super class declare exception 
            -> Can declare same exception
            -> Can declare exception lower the hierarchy
            -> Can choose not to declare any exception 
  
Overloading 
  - Same signature
  - Return type doesn't matter
  - Visiblity doesn't matter
  

  
============================================================================================
Polymorphism
============================================================================================
Polymorphism is a OOPs concept where one name can have many forms.

Types:
	- Compile Time (static binding)
		- Method overloading
	- Runtime (Dynamic Binding)
		- Method Overrinding

Upcasting 
	- Creating an Object of derived class and treating it as a reference to base class.

- Private method cannot be overriden as well as overloaded in Base-Derived Hierarchy
- Only methods can be polymorphic
- Variable cannot be polymorphic
- Static methods doesn't behave polymorphic

* If you upcast, you cant call the new methods(other that it has) in the derived class.
* Upcast is always safe because the base class cannot have a bigger interface than the derived class.
* Downcast is not safe
* ClassCastException is thrown if it is not of the type.

class Base{
	void m1() {
		System.out.println("m1 in base");
	}
	void m3() {
		System.out.println("not overriden in Derived class");
	}
}
class Derived extends Base{
	void m1() {
		System.out.println("m1 in derived");
	}
	void m2() {
		System.out.println("un overriden");
	}
}

public class Test1 {
	public static void main(String[] args) {
		Base b = new Derived();
		b.m2();								// Compilation error (m2 should be available in Base class)
	}
}


============================================================================================
Interface and Abstract class
============================================================================================
abstract class	
	- It can have zero or more abstract method.
	- If one of the method is abstract, class should be abstract
	- If the implementation class doesn't implement all the abstract method, then this class should be abstract.
	- Object cannot be created.

interface
	- 100% abstraction 
	- field inside interface is implicity static and final
	- methods are implicitly public
	- it can extends multiple interface.
	
* Interface can only extends another interface not implements it.
	
Scenario:
1. If you have interface having some abstract method and another class having implementation of method in 
   that interface (Though it doesn't implements interface). 
       And in the Implentation class which extends Class and implements that interface, methods in the interface
       need not to define in it.
       	    Since the defination is present in the class.

Interface vs Abstract class
    - Interface is used when one want method with no defination as well as no member variable.
    - Interface is used when you want a class to implements multiple interface.
    
    - Abstract class is prefer where you want method defination as well as abstract method
    - Abstract class is prefer when you want some member variables.
	    
* Fields defined in inteface should not be blank final. Value should be assigned when declared.
* Inteface can be private if it is nested within the class.
* Interface cannot be private if it is nested within the another interface.
	    
TODO : Name collision in interface	

============================================================================================
Inner Class
============================================================================================
Nested Class  Type:
	- Static nested class
	- Non-static nested class

Static Nested Class	
	- Static nested class can contain both static and non static member
	- We can access only static member of outer static class inside nested static class.
			- We cannot access non-static member
	- Static nested class can be abstract and final
	- Access to nested static class methods (Same will be for fields)
		~ OuterClass.InnerClass.method()      			//Access to static method
		~ new OuterClass.InnerClass().method()			//Access to non-static method.
	- For each nested class separate .class file will be genereted (Ex- OuterClass$NestedClass.class)
	
Non-Static Nested Class 
	- Also called inner Class
	- Types 
		~ Member Inner class
		~ Local Inner Class
		~ Anonymours Inner Class
		
	Member Inner Class 
		- It must only contains non-static members. (Static members are not allowed)
		- Static field is allowed only if it is final. And it should be initialized at time of declaration
			~ static methods are not allowed even if it is final
		- Its should not contain static block.
		- Both static and non-static member of Outer class can be access 
		- How to Access
			~ new OuterClass().new InnerClass().method();
		- All member of outer class can be accessed in inner class and vice versa irrespective of access specifier(visibility).
		- Member inner class can be final as well abstract but not both.
		
	Local Inner Class	
		- 
	






  
  
  

